--- dillo-0.8.4/dpi/file.c.orig	2004-12-28 21:08:13.000000000 +0100
+++ dillo-0.8.4/dpi/file.c	2005-01-22 21:46:07.825296392 +0100
@@ -15,6 +15,7 @@
  * With new HTML layout.
  */
 
+#define _GNU_SOURCE
 #include <pthread.h>
 
 #include <ctype.h>           /* for tolower */
@@ -32,6 +33,7 @@
 #include <signal.h>
 #include <errno.h>           /* for errno */
 #include <glib.h>
+#include <zlib.h>
 
 #include "dpiutil.h"
 
@@ -71,7 +73,7 @@
 /*
  * Forward references
  */
-static const char *File_content_type(const char *filename);
+static const char *File_content_type(const char *filename, int *gzipped);
 static gint File_get_file(ClientInfo *Client,
                           const gchar *filename,
                           struct stat *sb,
@@ -401,7 +403,7 @@
       cont = "application/executable";
       filecont = "Executable";
    } else {
-      filecont = cont = File_content_type(finfo->full_path);
+      filecont = cont = File_content_type(finfo->full_path, NULL);
       if (!filecont || !strcmp(filecont, "application/octet-stream"))
          filecont = "unknown";
    }
@@ -525,13 +527,24 @@
 /*
  * Return a content type based on the extension of the filename.
  */
-static const char *File_ext(const char *filename)
+static const char *File_ext(const char *filename, int *gzipped)
 {
-   char *e;
+   char *e, *e2;
 
    if ( !(e = strrchr(filename, '.')) )
       return NULL;
 
+   if ((e > filename) && !strcasecmp(e+1, "gz") &&
+       ((e2 = memrchr(filename, '.', e-filename)) != NULL)) {
+	   e2++;
+	   if (!strncasecmp(e2, "html.", 5) ||
+	       !strncasecmp(e2, "htm.", 4) ||
+	       !strncasecmp(e2, "shtml.", 6)) {
+		   if(gzipped != NULL)
+			*gzipped = 1;
+		   return "text/html";
+	   }
+   }
    e++;
 
    if (!strcasecmp(e, "gif")) {
@@ -554,12 +567,12 @@
  * Based on the extension, return the content_type for the file.
  * (if there's no extension, analyze the data and try to figure it out)
  */
-static const char *File_content_type(const char *filename)
+static const char *File_content_type(const char *filename, int *gzipped)
 {
    gint fd;
    const gchar *ct;
 
-   if (!(ct = File_ext(filename))) {
+   if (!(ct = File_ext(filename, gzipped))) {
       /* everything failed, let's analyze the data... */
       if ((fd = open(filename, O_RDONLY | O_NONBLOCK)) != -1) {
          gchar buf[256];
@@ -582,16 +595,29 @@
 {
    int res;
    struct stat sb;
+   char *tmp_filename = (char*)filename, *p;
 
    if (stat(filename, &sb) != 0) {
+      char *e = strrchr(filename, '.');
+      if ((e == NULL) || strcasecmp(e + 1, "gz")) {
+	 if ((p = malloc(strlen(filename) + 4)) != NULL) {
+	    tmp_filename = p;
+	    strcpy(tmp_filename, filename);
+	    strcat(tmp_filename, ".gz");
+	    filename = tmp_filename;
+	 }
+      }
+   }
+
+   if (stat(tmp_filename, &sb) != 0) {
       /* stat failed, prepare a file-not-found error. */
       res = FILE_NOT_FOUND;
    } else if (S_ISDIR(sb.st_mode)) {
       /* set up for reading directory */
-      res = File_get_dir(Client, filename, orig_url);
+      res = File_get_dir(Client, tmp_filename, orig_url);
    } else {
       /* set up for reading a file */
-      res = File_get_file(Client, filename, &sb, orig_url);
+      res = File_get_file(Client, tmp_filename, &sb, orig_url);
    }
 
    if (res == FILE_NOT_FOUND) {
@@ -602,8 +628,10 @@
       sock_handler_printf(Client->sh, 1,
          "<dpi cmd='send_status_message' msg='"
          "Failed to open the %s %s'>",
-         S_ISDIR(sb.st_mode) ? "directory" : "file", filename);
+         S_ISDIR(sb.st_mode) ? "directory" : "file", tmp_filename);
    }
+   if(tmp_filename != filename)
+      free(tmp_filename);
 }
 
 /*
@@ -644,6 +672,8 @@
    const gchar *ct;
    char buf[LBUF];
    gint fd, st;
+   int gzipped = 0;
+   gzFile gzdata;
 
    if ( (fd = open(filename, O_RDONLY | O_NONBLOCK)) < 0)
       return FILE_NO_ACCESS;
@@ -653,15 +683,32 @@
     * todo: a better approach could be to detect&reject those types we know
     * for sure we don't handle (as gzip, bzip, ELF, etc)
     */
-   ct = File_content_type(filename);
+   ct = File_content_type(filename, &gzipped);
    if (!ct || !strcmp(ct, "application/octet-stream"))
       ct = "text/plain";
 
-
    /* Send DPI command */
    sock_handler_printf(Client->sh, 1,
       "<dpi cmd='start_send_page' url='%s'>\n", orig_url);
 
+  if (gzipped) {
+      /* Send HTTP stream */
+      sock_handler_printf(Client->sh, 0,
+         "Content-Type: %s\n\n", ct);
+
+      gzdata = gzdopen(fd, "r");
+      do {
+          if ((st = gzread(gzdata, buf, LBUF)) > 0) {
+      	if (sock_handler_write(Client->sh, buf, st, 0) != 0)
+      	    break;
+          } else if (st < 0) {
+      	perror("[read]");
+      	if (errno == EINTR || errno == EAGAIN)
+      	    continue;
+          }
+      } while (st > 0);
+      gzclose(gzdata);
+  } else {
    /* Send HTTP stream */
    sock_handler_printf(Client->sh, 0,
       "Content-Type: %s\n"
@@ -679,6 +726,7 @@
             continue;
       }
    } while (st > 0);
+   }
 
    /* todo: It may be better to send an error report to dillo instead of
     * calling abort from g_error() */
--- dillo-0.8.4/dpi/Makefile.am.orig	2004-11-21 12:16:00.000000000 +0100
+++ dillo-0.8.4/dpi/Makefile.am	2005-01-22 20:00:41.712011792 +0100
@@ -18,7 +18,7 @@
 ftp_filter_dpi_LDADD = @GLIB_LIBS@
 https_filter_dpi_LDADD = @GLIB_LIBS@ @LIBSSL_LIBS@
 hello_filter_dpi_LDADD = @GLIB_LIBS@
-file_dpi_LDADD = @GLIB_LIBS@ @LIBPTHREAD_LIBS@
+file_dpi_LDADD = @GLIB_LIBS@ @LIBPTHREAD_LIBS@ -lz
 
 file_dpi_LDFLAGS = @LIBPTHREAD_LDFLAGS@
 
